// Update prices and advice for each cryptocurrency
const updatePrices = async () => {
    const urls = {
        bitcoin: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd',
        ethereum: 'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd',
        dogecoin: 'https://api.coingecko.com/api/v3/simple/price?ids=dogecoin&vs_currencies=usd'
    };

    const formatPrice = (price) => {
        return price.toLocaleString('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
    };

    const fetchPriceAndUpdateChart = async (crypto, chartId, priceId, adviceId) => {
        try {
            const response = await fetch(urls[crypto]);
            const data = await response.json();
            const price = data[crypto].usd;
            document.getElementById(priceId).textContent = `Current Price: ${formatPrice(price)}`;
            provideAdvice(price, adviceId);

            const chart = Chart.getChart(chartId); // Get the chart if it has been created
            if (chart) {
                chart.data.labels.push(new Date().toLocaleTimeString());
                chart.data.datasets.forEach((dataset) => {
                    dataset.data.push(price);
                });
                chart.update();
            } else {
                const ctx = document.getElementById(chartId).getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [new Date().toLocaleTimeString()],
                        datasets: [{
                            label: `${crypto.charAt(0).toUpperCase() + crypto.slice(1)} Price (USD)`,
                            data: [price],
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: false,
                                ticks: {
                                    callback: function(value) {
                                        return formatPrice(value); // Format y-axis ticks
                                    }
                                }
                            }
                        }
                    }
                });
            }
        } catch (error) {
            console.error(`Error fetching ${crypto} price:`, error);
        }
    };

    fetchPriceAndUpdateChart('bitcoin', 'btcChart', 'btcPrice', 'btcAdvice');
    fetchPriceAndUpdateChart('ethereum', 'ethChart', 'ethPrice', 'ethAdvice');
    fetchPriceAndUpdateChart('dogecoin', 'dogeChart', 'dogePrice', 'dogeAdvice');
};

const provideAdvice = (currentPrice, adviceId) => {
    const prices = [currentPrice]; // This should ideally be a history of prices, not just the current price
    const shortTerm = calculateMovingAverage(prices, 5); // 5-point moving average
    const longTerm = calculateMovingAverage(prices, 20); // 20-point moving average

    let advice;
    if (shortTerm > longTerm && prices[prices.length - 2] <= longTerm) {
        advice = 'Buy - Short-term trend is rising above long-term trend.';
    } else if (shortTerm < longTerm && prices[prices.length - 2] >= longTerm) {
        advice = 'Sell - Short-term trend is falling below long-term trend.';
    } else {
        advice = 'Hold - The market is stable now.';
    }

    document.getElementById(adviceId).textContent = `Advice: ${advice}`;
};

const calculateMovingAverage = (data, numPoints) => {
    // Placeholder for calculating moving averages
    return data.reduce((a, b) => a + b, 0) / numPoints;
};

updatePrices();
setInterval(updatePrices, 20000); // Update every 20 seconds
